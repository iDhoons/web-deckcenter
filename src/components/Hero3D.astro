---
// Hero3D - 사실적인 3D 데크 시각화
---

<div class="hero-3d-container" id="hero3d" role="img" aria-label="3D 데크 시각화">
  <div class="hero-3d-loading" id="hero3d-loading" aria-live="polite" aria-busy="true">
    <div class="loading-spinner" aria-hidden="true"></div>
    <span class="sr-only">3D 모델 로딩 중…</span>
  </div>
</div>

<style>
  .hero-3d-container {
    position: relative;
    width: 100%;
    height: 100%;
    min-height: 500px;
    max-height: 700px;
    overflow: hidden;
    border-radius: var(--radius-lg);
    background: linear-gradient(135deg, #f5f0eb 0%, #ffffff 50%, #ebe5df 100%);
  }

  [data-theme="dark"] .hero-3d-container {
    background: linear-gradient(135deg, #1a1512 0%, #0f0d0b 50%, #1a1512 100%);
  }

  /* 로딩 인디케이터 */
  .hero-3d-loading {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: inherit;
    z-index: 10;
    transition: opacity 0.5s ease;
  }

  .hero-3d-loading.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--color-warm-200);
    border-top-color: var(--color-accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  @media (max-width: 768px) {
    .hero-3d-container {
      min-height: 350px;
      max-height: 450px;
    }
  }

  /* 스크린 리더 전용 */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>

<script>
  import * as THREE from 'three';

  // === 전역 상태 ===
  let scene: THREE.Scene | null = null;
  let camera: THREE.PerspectiveCamera | null = null;
  let renderer: THREE.WebGLRenderer | null = null;
  let deckGroup: THREE.Group | null = null;
  let frameId: number | null = null;
  let isInitialized = false;

  // === 설정 ===
  const DECK_CONFIG = {
    // 보드 치수 (Three.js units, 1 unit ≈ 100mm)
    boardLength: 18,
    boardWidth: 1.2,
    boardThickness: 0.22,
    boardCount: 14,
    gapWidth: 0.05,
    // 약간의 랜덤 배치
    randomOffset: 0.02,
  };

  // 품질 설정 (디바이스 기반)
  function getQualitySettings() {
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const isLowEnd = navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : false;

    return {
      shadowMapSize: isMobile || isLowEnd ? 1024 : 2048,
      pixelRatio: isMobile ? Math.min(1.5, window.devicePixelRatio) : Math.min(2, window.devicePixelRatio),
      antialias: !isMobile,
      shadowEnabled: true,
    };
  }

  // 테마 감지
  function isDarkMode(): boolean {
    return document.documentElement.getAttribute('data-theme') === 'dark';
  }

  // === 텍스처 생성 (절차적) ===
  function createWoodTexture(): THREE.CanvasTexture {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d')!;

    // 기본 우드 색상
    const baseColor = isDarkMode() ? '#5a4a3a' : '#a08060';
    ctx.fillStyle = baseColor;
    ctx.fillRect(0, 0, 512, 512);

    // 나뭇결 라인 생성
    const grainColors = isDarkMode()
      ? ['#4a3a2a', '#6a5a4a', '#5a4535', '#7a6a5a']
      : ['#8a6a4a', '#c0a080', '#9a7a5a', '#b09070'];

    for (let i = 0; i < 80; i++) {
      const y = Math.random() * 512;
      const width = 1 + Math.random() * 3;
      const alpha = 0.1 + Math.random() * 0.3;

      ctx.strokeStyle = grainColors[Math.floor(Math.random() * grainColors.length)];
      ctx.globalAlpha = alpha;
      ctx.lineWidth = width;

      ctx.beginPath();
      ctx.moveTo(0, y);

      // 약간 굴곡진 라인
      for (let x = 0; x < 512; x += 20) {
        const offsetY = (Math.random() - 0.5) * 4;
        ctx.lineTo(x, y + offsetY);
      }
      ctx.stroke();
    }

    ctx.globalAlpha = 1;

    // 미세한 노이즈 추가
    const imageData = ctx.getImageData(0, 0, 512, 512);
    for (let i = 0; i < imageData.data.length; i += 4) {
      const noise = (Math.random() - 0.5) * 15;
      imageData.data[i] = Math.max(0, Math.min(255, imageData.data[i] + noise));
      imageData.data[i + 1] = Math.max(0, Math.min(255, imageData.data[i + 1] + noise));
      imageData.data[i + 2] = Math.max(0, Math.min(255, imageData.data[i + 2] + noise));
    }
    ctx.putImageData(imageData, 0, 0);

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(3, 0.5);
    return texture;
  }

  // === 씬 생성 ===
  function createScene(): THREE.Scene {
    const scene = new THREE.Scene();
    const dark = isDarkMode();

    scene.background = new THREE.Color(dark ? 0x0f0d0b : 0xf5f0eb);
    scene.fog = new THREE.Fog(dark ? 0x0f0d0b : 0xf5f0eb, 15, 40);

    return scene;
  }

  // === 조명 설정 ===
  function setupLighting(scene: THREE.Scene, quality: ReturnType<typeof getQualitySettings>) {
    const dark = isDarkMode();

    // 환경광
    const ambientLight = new THREE.AmbientLight(
      dark ? 0xffeedd : 0xffffff,
      dark ? 0.4 : 0.6
    );
    scene.add(ambientLight);

    // 메인 태양광 (그림자)
    const sunLight = new THREE.DirectionalLight(
      dark ? 0xffeedd : 0xfff8f0,
      dark ? 0.8 : 1.0
    );
    sunLight.position.set(8, 12, 8);
    sunLight.castShadow = quality.shadowEnabled;

    if (quality.shadowEnabled) {
      sunLight.shadow.mapSize.width = quality.shadowMapSize;
      sunLight.shadow.mapSize.height = quality.shadowMapSize;
      sunLight.shadow.camera.near = 1;
      sunLight.shadow.camera.far = 40;
      sunLight.shadow.camera.left = -15;
      sunLight.shadow.camera.right = 15;
      sunLight.shadow.camera.top = 15;
      sunLight.shadow.camera.bottom = -15;
      sunLight.shadow.bias = -0.0001;
      sunLight.shadow.normalBias = 0.02;
    }
    scene.add(sunLight);

    // 필 라이트 (그림자 영역 밝히기)
    const fillLight = new THREE.DirectionalLight(
      dark ? 0x8899aa : 0xaabbcc,
      dark ? 0.2 : 0.3
    );
    fillLight.position.set(-5, 5, -5);
    scene.add(fillLight);

    // 림 라이트 (가장자리 강조)
    const rimLight = new THREE.DirectionalLight(0xffffff, 0.15);
    rimLight.position.set(0, 3, -10);
    scene.add(rimLight);
  }

  // === 데크 보드 생성 ===
  function createDeckBoards(scene: THREE.Scene) {
    const group = new THREE.Group();

    // 보드 지오메트리 (모서리 살짝 깎기 위해 bevel 효과)
    const boardGeometry = new THREE.BoxGeometry(
      DECK_CONFIG.boardWidth,
      DECK_CONFIG.boardThickness,
      DECK_CONFIG.boardLength,
      1, 1, 1
    );

    // 텍스처 생성
    const woodTexture = createWoodTexture();

    // 머티리얼
    const boardMaterial = new THREE.MeshStandardMaterial({
      map: woodTexture,
      roughness: 0.82,
      metalness: 0.02,
      envMapIntensity: 0.2,
    });

    // 보드 배치
    const totalWidth = DECK_CONFIG.boardCount * (DECK_CONFIG.boardWidth + DECK_CONFIG.gapWidth);
    const startX = -totalWidth / 2 + DECK_CONFIG.boardWidth / 2;

    for (let i = 0; i < DECK_CONFIG.boardCount; i++) {
      const board = new THREE.Mesh(boardGeometry, boardMaterial.clone());

      // 위치 (약간의 랜덤 오프셋)
      const x = startX + i * (DECK_CONFIG.boardWidth + DECK_CONFIG.gapWidth);
      const randomY = (Math.random() - 0.5) * DECK_CONFIG.randomOffset;
      const randomZ = (Math.random() - 0.5) * 0.3;

      board.position.set(x, randomY, randomZ);

      // 각 보드마다 약간 다른 색상
      const hueShift = (Math.random() - 0.5) * 0.05;
      const material = board.material as THREE.MeshStandardMaterial;
      material.color.offsetHSL(hueShift, 0, (Math.random() - 0.5) * 0.1);

      board.castShadow = true;
      board.receiveShadow = true;

      group.add(board);
    }

    // 그룹 약간 기울이기 (더 입체적으로 보이게)
    group.rotation.x = -0.05;

    scene.add(group);
    return group;
  }

  // === 바닥 (그림자 받기) ===
  function createGround(scene: THREE.Scene) {
    const groundGeometry = new THREE.PlaneGeometry(60, 60);
    const groundMaterial = new THREE.ShadowMaterial({
      opacity: isDarkMode() ? 0.3 : 0.15,
    });

    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -DECK_CONFIG.boardThickness / 2 - 0.05;
    ground.receiveShadow = true;

    scene.add(ground);
  }

  // === 메인 초기화 ===
  function initHero3D() {
    if (isInitialized) return;

    const container = document.getElementById('hero3d');
    const loadingEl = document.getElementById('hero3d-loading');
    if (!container) return;

    const width = container.clientWidth;
    const height = container.clientHeight;
    const quality = getQualitySettings();

    // Scene
    scene = createScene();

    // Camera
    camera = new THREE.PerspectiveCamera(35, width / height, 0.5, 100);
    camera.position.set(14, 10, 14);
    camera.lookAt(0, 0, 0);

    // Renderer
    renderer = new THREE.WebGLRenderer({
      antialias: quality.antialias,
      alpha: false,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(quality.pixelRatio);
    renderer.shadowMap.enabled = quality.shadowEnabled;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = isDarkMode() ? 0.9 : 1.1;

    container.appendChild(renderer.domElement);

    // 씬 구성
    setupLighting(scene, quality);
    deckGroup = createDeckBoards(scene);
    createGround(scene);

    // 로딩 완료
    if (loadingEl) {
      loadingEl.classList.add('hidden');
      loadingEl.setAttribute('aria-busy', 'false');
    }

    // 애니메이션
    let time = 0;
    const orbitRadius = 18;
    const orbitHeight = 10;
    const orbitSpeed = 0.08;

    function animate() {
      frameId = requestAnimationFrame(animate);
      time += 0.01;

      if (camera && renderer && scene) {
        // 부드러운 원형 궤도 회전
        camera.position.x = Math.sin(time * orbitSpeed) * orbitRadius;
        camera.position.z = Math.cos(time * orbitSpeed) * orbitRadius;
        camera.position.y = orbitHeight + Math.sin(time * orbitSpeed * 0.5) * 1.5;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
    }

    animate();
    isInitialized = true;

    // 리사이즈 핸들러
    function handleResize() {
      if (!container || !camera || !renderer) return;

      const width = container.clientWidth;
      const height = container.clientHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    window.addEventListener('resize', handleResize);
  }

  // === 정리 ===
  function cleanup() {
    if (frameId !== null) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }

    if (scene) {
      scene.traverse((object) => {
        if (object instanceof THREE.Mesh) {
          object.geometry?.dispose();
          if (Array.isArray(object.material)) {
            object.material.forEach((m) => {
              if (m.map) m.map.dispose();
              m.dispose();
            });
          } else if (object.material) {
            if ((object.material as THREE.MeshStandardMaterial).map) {
              (object.material as THREE.MeshStandardMaterial).map?.dispose();
            }
            object.material.dispose();
          }
        }
      });
      scene.clear();
      scene = null;
    }

    if (renderer) {
      renderer.dispose();
      renderer.domElement.remove();
      renderer = null;
    }

    camera = null;
    deckGroup = null;
    isInitialized = false;
  }

  // === 테마 변경 감지 ===
  function handleThemeChange() {
    cleanup();
    initHero3D();
  }

  // === 이벤트 리스너 ===
  // 초기 로드
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHero3D);
  } else {
    initHero3D();
  }

  // Astro View Transitions
  document.addEventListener('astro:page-load', () => {
    cleanup();
    initHero3D();
  });

  document.addEventListener('astro:before-swap', cleanup);

  // 테마 변경 감지 (MutationObserver)
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.attributeName === 'data-theme') {
        handleThemeChange();
        break;
      }
    }
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['data-theme'],
  });
</script>
